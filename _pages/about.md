---
layout: about
title: about
permalink: /
subtitle: ECE @ <a href='https://engineering.purdue.edu/ECE'>Purdue</a> | <a href='araviki@purdue.edu'>araviki@purdue.edu</a>

profile:
  align: right
  image: profile_pic.jpg
  image_circular: true # crops the image to make it circular
  more_info: 
  
news: true # includes a list of news items
latest_posts: true # includes a list of the newest posts
selected_papers: true # includes a list of papers marked as "selected={true}"
social: false # includes social icons at the bottom of the page
---

I'm a second-year undergraduate @ Purdue, pursuing a B.Sc in CompE.

My primary interest revolves arould building robust user-facing solutions at the intersection of applied AI, explainable learning paradigms and interoperablile systems. I enjoy research-driven environments aimed at taking concepts to tangible products. 

<b>Automatability</b>, <b>reproducibility</b> and <b>accessability</b> remain the core of my work. 

I'm currently looking to involved in the following: 
- *Vision Generation Algorithms*, 
- *Robot-Environment Interactions*, 
- *GPU Programming*, 
- *Digital Design ↔️ ML/DL*. 

I'd highly appreciate any mentorship or suggestions for research labs @ Purdue that focus on these topics!

## background 


## interests

I'm super excited about the Partner as a Product (PaaP) era we're entering into. I aim to gain experience across these systems (that I believe) we're (going to) base our lives on, from hardware-level programming to cloud-based HPA lifecycles. Majoring in ECE gives me the oppurtunity to develop myself in these areas. 

I've not yet decided what my speciality is, but I'd like to think *creating* solutions is it. I hate entering projects which have reached their maturity, because that limits inherent innovation (in my opinion, of course). This is the main reason why I like working in different (fields of) research, while maintaining my touch of applicability. 

I hate the concept of blind faith, but these beliefs have never let me down: 
- *Every unexplained idea in one field finds its explanation within another*
- *Reliable software is a by-product of a robust design process;*
- *Quality work is replicable, replicable work guarantees quality;*
- *If it's not use(d)(ful), what's the point of building it?*


