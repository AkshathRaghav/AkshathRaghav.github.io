<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "http://www.w3.org/TR/REC-html40/loose.dtd"> <html><body> <p><a href="https://openaccess.thecvf.com/content/ICCV2023/papers/Gholami_ETran_Energy-Based_Transferability_Estimation_ICCV_2023_paper.pdf" rel="external nofollow noopener" target="_blank">Paper</a> <a href="https://github.com/AkshathRaghav/ptmrank/blob/main/ptmrank/metrics/ETran.py" rel="external nofollow noopener" target="_blank">Code</a></p> <h2 id="what-is-it">What (is it)?</h2> <p>ETran was proposed on the hypothesis that evaluating whether target dataset features are IND or OOD for a given PTM would be enough for a good MTE. The metric works based off the concept of statistical physics that correlates energy of a system to the likelihood of a sample being present in the original distribution.</p> <p><strong>Cool Stuff</strong>:</p> <ul> <li>Outlines a way to deal with object detection tasks using bounding boxes;</li> <li>Ignores the complexities of handling target labels;</li> <li>Makes explainable estimations about the knowledge relationship between source model and target dataset;</li> </ul> <p>The main part of the metric involves the idea of Energy-Based Models (EBMs). EBMs are a class of models that use an energy function (may (or may not) be parameterized) to assign a scalar energy value to each possible configuration of the input data. It’s simple, anything that relates a low return value with good direction during training can be an energy function. For simpler models, this can be MSE or Cross-Entropy. If you’re getting more complex, certain layers or modules themselves are made for this purpose.</p> <p>At all levels, the energy function is used to derive a probability distribution through the Gibbs distribution. The below equation shows that the probability of a particular outcome y given the input x decreases exponentially with increasing energy E(x,y). Just replace E(x,y) here with your energy function above and you’re set to run some visualizations on your PTM.</p> <h2 id="why-do-we-need-it">Why (do we need it)?</h2> <ul> <li>Previous methods (think before SDFA and NLEEP) typically fail when the target dataset diverges significantly from the source dataset’s distribution. When the target dataset is OOD compared to the pre-trained model, the extracted features can become unreliable. (Note the word <em>unreliable</em> – it means “not robust”, but can be right sometimes.)</li> <li>The effectiveness of these methods is often compromised by the differences in features before and after fine-tuning, due to variations in source and target domains.</li> <li>ETran is also more efficient (think 2x and more) because it does not require extensive label information or complex optimization processes. The energy score is label- and optimization-free, making it a fast and easy-to-use metric for transferability estimation.</li> </ul> <h2 id="how-does-it-work">How (does it work)?</h2> <p>ETran’s transferability assessment includes three primary scores:</p> <ul> <li>Energy Score: Measures the likelihood of the target dataset being <em>compatible</em> with the pre-trained model.</li> <li>Classification Score: Uses Linear Discriminant Analysis (LDA) to project features into a higher D space, maximizing inter-class variance and minimizing intra-class variance.</li> <li>Regression Score: Uses Singular Value Decomposition (SVD) to evaluate the transferability for object detection tasks. <em>Pretty interesting</em>.</li> </ul> <h3 id="energy-score-s_en">Energy Score (S_{en}):</h3> <p>Here is an optimized view of the process:</p> \[S_{en} = \frac{1}{|C|} \sum_{i \in C} \log \left( \sum_{j=1}^{d} e^{f_{ij}} \right)\] <p>where,</p> <ul> <li> <strong>\(\( f_{ij} \)\)</strong>: Feature value for the (i)-th sample and (j)-th feature dimension.</li> <li> <strong>\(\( d \)\)</strong>: Feature dimension.</li> <li> <strong>\(\( C \)\)</strong>: Total samples</li> </ul> <div class="theorem"> <div class="theorem-title">Theorem (Energy Score Equation) </div> <div class="theorem-contents"> $$ S_{en} = \frac{1}{|C|} \sum_{i \in C} \log \left( \sum_{j=1}^{d} e^{f_{ij}} \right) $$ where, * **$$\( f_{ij} \)$$**: Feature value for the \(i\)-th sample and \(j\)-th feature dimension. * **$$\( C \)$$**: Total samples. * **$$\( d \)$$**: Feature dimension. </div> </div> <p>Now, imagine we have Guassian clusters as our IND data and a Uniform distribution as our OOD data. This is how they’d look, assuming a sample size of 1000:</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/tldr/etran/post-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/tldr/etran/post-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/tldr/etran/post-1400.webp"></source> <img src="/assets/img/tldr/etran/post.png" class="z-depth-1 center" width="600px" height="auto" style="object-fit: cover" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Instead of a whole model, and to ignore the pretext of training, we’ll use PCA for simplicity as an “embedding function”. We’ll also take the Mean Squared Error as the energy function. Here’s how we can find the energy and probability density.</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def extract_features(data, n_components=3):
    pca = PCA(n_components=n_components)
    return pca.fit_transform(data)

def calculate_energy(features):
    return np.sum(features**2, axis=1)

def calculate_probability_density(energy):
    exp_neg_energy = np.exp(-energy)
    return exp_neg_energy / np.sum(exp_neg_energy)
</code></pre></div></div> <p>Here’s how the “extracted” features look:</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/tldr/etran/post-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/tldr/etran/post-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/tldr/etran/post-1400.webp"></source> <img src="/assets/img/tldr/etran/post.png" class="z-depth-1 center" width="600px" height="auto" style="object-fit: cover" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Now, let’s see how the energy and probability distributions look as a KDE plot:</p> <figure> <picture> <source class="responsive-img-srcset" media="(max-width: 480px)" srcset="/assets/img/tldr/etran/post-480.webp"></source> <source class="responsive-img-srcset" media="(max-width: 800px)" srcset="/assets/img/tldr/etran/post-800.webp"></source> <source class="responsive-img-srcset" media="(max-width: 1400px)" srcset="/assets/img/tldr/etran/post-1400.webp"></source> <img src="/assets/img/tldr/etran/post.png" class="z-depth-1 center" width="600px" height="auto" style="object-fit: cover" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p><strong>Note</strong>:</p> <ul> <li>When looking at the energy scores, the KDE plot show that IND samples have lower energy (peak towards the left) while OOD samples have a higher energy (peak towards right). This validates the initial hypothesis.</li> <li>When looking at the probability densities, the KDE plot sh sthat INR samples have higher densities (shifted towards right) while OOD samples have lower density (peak towards left). This confirms the method of using Gibbs.</li> </ul> <h2 id="when-does-it-fail">When (does it fail)?</h2> <ul> <li>Dealing purely with \(S_{en}\) is <strong>unreliable</strong>. This purely interfaces between target embeddings and the source model’s embedding functions. Consider a classification task for a PTM with an embedding function which was trained on distribution which matches the target. The energy score will be super low, and high likelihood for samples. However, we’re completely ignoring the rest of the network and the classification labels. Different PTMs with similar embedding layers might be clustered together, regardless of their accuracy. Thus, use classification based scores like LogME, LEEP, PACTran and \(S_{cls}\) in addition to the \(S_{en}\) score.</li> </ul> <h2 id="future-work">Future Work?</h2> </body></html>